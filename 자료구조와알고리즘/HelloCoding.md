# 챕터1. 알고리즘 기초

## 이진 탐색 

이진탐색은 리스트의 원소들이 정렬되어 있을 때만 사용할 수 있음

이진탐색은 O(log n) 시간

## 빅오 표기법

알고리즘이 얼마나 빠른지 표시하는 방법

리스트의 크기가 증가할 때 연산 횟수가 어떻게 증가하는지를 표시함

## 연습문제 1-6

알파벳 A로 시작하는 사람들의 전화번호를 알아내는 방법의 실행 시간

### 풀이

O(n)

알파벳이 26개인데 A로 시작하는 사람들만 뽑아내면 대략 1/26 * n 만큼의 연산이 수행됨

하지만 빅오표기법에서 상수는 무시함

* 이유1. 리스트의 크기가 매우 커지면 상수는 큰 의미가 없음

* 이유2. 상수값보다는 리스트의 크기에 따른 연산수행의 변동성(기울기)가 빅오표기법의 관심사임

# 챕터2. 선택 정렬

## 배열과 연결리스트

배열은 메모리상에 일렬로 늘어선 공간에 각 원소가 순차적으로 저장됨

연결리스트의 각 원소는 메모리공간에 흩어져서 저장됨

그 공간에 원소와 다음 원소의 주소를 저장함

이러한 구조적 특징 때문에 배열은 검색시간은 O(1) 이지만 삽입/삭제 시간은 O(n) 

반대로 연결리스트는 삽입/삭제는 O(1)이지만 검색은 맨 앞의 원소부터 순차적으로 진행해야 되기 떄문에 O(n)의 시간 복잡도를 가짐

## 선택 정렬 

시간복잡도는 O(n^2)이다. 깔끔하지만 느린 정렬 알고리즘

## 연습문제 2-4

이진 탐색을 쓰고 있는 배열에 새로운 원소를 추가하면 어떻게 되는가?

### 풀이

일단 배열에 원소를 추가하면 추가한 원소는 가장 마지막 칸에 저장된다. 그러나 이진탐색을 사용하고 있기 때문에 배열의 모든 원소가 정렬되어 있어야 하므로 배열을 다시 정렬해야함

즉, 원소 추가할 때마다 배열을 다시 정렬해야함

## 연습문제 2-5

[연결리스트의 배열] 형태의 복합 자료형과 [배열]과 [연결리스트] 탐색 및 삽입 시 누가 빠른가?

### 풀이

### 탐색 시

배열 > 연결리스트의 배열 > 연결리스트

연결리스트의 배열 탐색 시 각 연결리스트의 시작점 주소를 갖고 있는 각 배열로 접근할 땐 O(1) 의 시간복잡도를 갖는 임의 접근이고 그 후 특정 원소까지는 순차접근함. 다만 온전히 연결리스트로 구성된 경우보다는 훨씬 짧은 탐색시간이 걸릴 것임

### 삽입 시

연결리스트 = 연결리스트의 배열 > 배열

📌연결리스트의 배열에서 배열의 특정 원소로 접근할 때 임의 접근이기 때문에 연결리스트와 같은 성능을 갖는다.

# 챕터3. 재귀

## 기본단계와 재귀단계

기본단계 = 가장 단순한 경우로 재귀단계를 끝내고 무한 반복에 빠지지 않게 함

재귀단계 = 자기 자신을 호출하는 단계

## 호출 스택

함수 호출마다 변수를 저장하고 있는데 이 떄 스택을 사용하여 저장하며 이것이 호출 스택임

각각의 호출이 자기만의 변수값 사본을 갖고 있음

# 챕터4. 퀵 정렬

## 분할정복

기본단계와 재귀단계로 이루어짐,즉 재귀임

## 퀵 정렬

평균적으로 O(n log n) 만큼의 성능을 가짐, 단 최악의 경우엔 O(n^2)

퀵 정렬을 구현하기 위해선 기준 원소를 무작위로 선택해야함, 그래야 O(n log n)의 시간복잡도를 갖게된다.

## 연습문제 4-4

이진탐색도 분할정복이다. 이진탐색을 분할정복으로 설명하면?

기본단계 = 배열의 길이가 1개이다, 더 이상 배열을 쪼갤 수 없음

재귀단계 = 배열을 쪼갤 중간값과 선택값이 같지 않다. 그래서 배열을 2등분한다

# 챕터5. 해시 테이블

## 해시 함수

문자열이 입력되면 숫자를 반환하는 함수

### 해시 함수의 특징

* 해시 함수는 기본적으로 문자열에 숫자를 일대일로 할당한다

* 해시 함수는 배열의 크기가 얼마나 되는지 알고 있다

## 해시 테이블

해시 함수와 배열이 합쳐져서 해시 테이블이란 자료구조가 된다

그냥 배열인데 해시 함수의 반환값이 저장됨

## 충돌

해시 함수에서 모든 키와 값을 일대일로 할당하는 것은 불가능하다

따라서 충돌이 발생할 수 있는데 이때 가장 간단한 해결방법은 배열에 연결리스트를 연결하는 것이다

## 성능

해시테이블은 탐색과 삽입/삭제 평균적인 경우 모두 O(1) 시간이 걸린다

하지만 최악의 경우엔 모두 O(n) 시간이 걸릴 수도 있다

* O(1) : 상수시간, 처리시간이 리스트의 크기에 상관없이 항상 일정

* O(log n) : 로그시간, 처리시간이 리스트의 크기에 비례하여 증가하지만 증가율은 점점 감소하는 형태

* O(n) : 선형시간, 처리시간이 리스트의 크기에 정비례하여 증가하는 형태

# 챕터6. 너비 우선 탐색(BFS)

## 그래프

그래프는 정점(node)와 간선(edge)로 이루어진다

## 너비 우선 탐색

너비 우선 탐색을 사용하여 답할 수 있는 질문

* A 에서 B 로 가는 경로가 존재하는가?

* A 에서 B 로 가는 최단 경로는 무엇인가?

## 큐

먼저 추가된 값이 먼저 나오는 자료구조

탐색에 사용할 수 없음

## 그래프의 구현

해시 테이블을 사용하여 그래프를 구현

해시 테이블은 대표적인 관계를 표시하는 자료구조

```py
#나(I)의 친구목록
graph = {}
graph["I"] = {"messi","ronaldo","curry"}
```

이 경우는 나(I)에서 친구들인 단방향 그래프임

무항뱡그래프(쌍방향)인 경우와 구별해야함

## 알고리즘 구현(내 네트워크에 NBA선수 최단경로 찾기)

1.확인할 명단을 넣을 큐를 준비한다

2.내 친구 명단을 넣고 하나 꺼낸다

3.그 친구가 NBA선수인지 확인한다.

4.3 이 참일 때, 작업완료
   
5.3 이 거짓일 때, 2에서 꺼낸 친구의 이웃을 모두 큐에 추가한다.

6.5를 반복한다

7.만약 큐가 비어 있으면 네트워크에 NBA선수는 없다.

```py
def search(name):
  search_queue = deque()
  search_queue += graph[name]
  searched = [] #이 배열은 이미 확인한 건을 추적하기 위한 것
  while search_queue:
    person = search_queue.popleft()
    if not person in searched: #이전에 확인하지 않은 건인지 확인
      if person_is_NBAPlayer(person):
        print person + " is a NBAPlayer!"
        return True
      else:
        search_queue += graph[person]
        searched.append[person]
    return False

search("I")      

```
# 챕터7. 다익스트라 알고리즘

너비 우선 탐색은 균일 그래프에서 최단 경로를 구할 때 사용

반면에 다익스트라 알고리즘은 가중 그래프에서 최단 거리를 구할 때 사용

## 용어 설명

* 싸이클 : 어떤 정점에서 출발해서 한 바퀴 돌아 같은 정점에서 끝남,싸이클을 지나면 최단 경로를 얻을 수 없음

## 구현

### 준비물

3개의 해시 테이블

* 그래프(이중 해시테이블)

* 가격

* 부모

1개의 배열

* 처리한 정점을 기록한 배열

### 알고리즘

1.출발점에서 가장 싼 정점을 찾는다

2.이웃 정점의 가격을 갱신한다

3.만약 이웃 정점의 가격을 갱신하면 부모도 갱신한다

4.해당 정점을 처리했다는 사실을 기록한다

5.모든 정점을 처리할때까지 반복한다

## 📌음의 가중치를 갖는 경우

음의 가중치를 갖는 경우엔 다익스트라 알고리즘을 사용할 수 없다

가장 싼 노드부터 차례대로 방문하고 한번 방문한 노드를 다시 방문하진 않는다

그런데 음의 가중치를 갖게 되면 먼저 방문하여 처리가 완료된 노드의 가격이 더 낮아지게 된다

이런 경우엔 다익스트라 알고리즘이 작동하지 않는다

물론 현실세계에서 음의 가중치를 갖는 경우는 드물다

# 챕터8. 탐욕 알고리즘

각각의 단계에서 최적의 수를 찾는 알고리즘

## NP-완전문제

모든 가능한 경우를 다 따져서 최단/최소를 구해야하는 문제

ex)외판원 문제, 집합 커버링 문제

### NP-완전문제 판별 참고사항

* 더 작은 하위문제로 변환할 수 없어서 "X의 모든 조합" 을 계산해야되는 경우

* 문제가 수열,집합을 포함하고 어려운 경우(...)

## 근사 알고리즘

탐욕 알고리즘은 각각의 단계에서 최적의 수를 찾지만 결과가 완벽하진 않음

하지만 여러 이유로 완벽한 정답보다는 유의미하지만 약간의 오류가 있는 답이 필요할 때다.

이 때 탐욕 알고리즘 같은 근사 알고리즘을 사용하면 됨

## 연습문제 8-1

탐욕 알고리즘을 써서 트럭의 공간을 최대한 가득 채우도록 상자를 고르기, 이렇게 나온 답이 최적인가?

### 풀이

1.남은 공간이 최소가 되는 상자를 골라 채워넣는다 

2.1을 반복한다

위와 같이 하더라도 남는 공간이 생길 수 있기 때문에 그 답이 최적은 아닐 수 있다

하지만 유의미한 답을 얻어낼 순 있다

## 연습문제 8-2

7일동안 유럽 어디든 갈 수 있고 각 장소마다 그곳의 가치를 숫자로 갖고 있을 때, 탐욕알고리즘을 써서 여행의 총 방문 가치를 최대화하는 법?

1.남은 일정동안 갈 수 있는 여행지 중 방문 가치가 가장 높은 곳을 고른다

2.이미 방문한 여행지를 제외하고 1을 반복한다

## 연습문제 8-3,4,5

다음 중 탐욕 알고리즘은?

### 큌 정렬

아니다. 기준원소를 임의로 선택해야 O(n log n) 을 갖게된다

임의선택이면 각 단계마다 최적의 선택을 하는 탐욕 알고리즘과는 다르다

### 너비 우선 탐색,다익스트라 알고리즘

맞다. 너비 우선 탐색이던 다익스트라 알고리즘이던 각 단계에서 최적의 해를 찾아 궁극적인 해를 찾아가는 과정임

# 챕터9. 동적 프로그래밍

하위의 작은 문제들을 풀고, 이를 이용해서 더 큰 문제를 풀어나가는 방식

모든 동적 프로그래밍 알고리즘은 격자로 시작한다

하위 문제들이 서로 의존적인 경우 사용할 수 없다

## 배낭 채우기 문제

격자의 세로축 : 물건, 가로축 : 파운드

배낭의 크기를 늘려가면서 물건을 하나씩 늘려가면서 격자로 구성함

격자의 중간단계 각각이 하위 문제가 됨 (1파운드에 기타,스테레오를 넣는경우 처럼)

격자의 마지막 단계에서 각각의 하위 단계에 적어놓았던 답들을 조합하여 작성

## 최장 공통 부분 문자열

| |H|I|S|H|
|--|--|--|--|--|
|F|0|0|0|0|
|I|0|1|0|0|
|S|0|0|2|0|
|H|0|0|0|3|

1.글자가 다르면 0 

2.글자가 같으면 좌측 상단 칸의 값 + 1 

의사코드

```py
if word_a[i] == word_b[j]:
  cell[i][j] == cell[i-1][j-1] + 1
else:
  cell[i][j] = 0
```

## 최장 공통 부분열

| |F|O|S|H|
|--|--|--|--|--|
|F|1|1|1|1|
|I|1|1|1|1|
|S|1|1|2|2|
|H|1|1|2|3|

1.글자가 같지 않으면 위쪽 칸과 왼쪽 칸 중에 더 큰 값 선택

2.글자가 같으면 좌측 상단 칸의 값 + 1 

의사코드

```py
if word_a[i] == word_b[j]:
  cell[i][j] == cell[i-1][j-1] + 1
else:
  cell[i][j] = max(cell[i-1][j],cell[i][j-1])
```

# 챕터10. KNN 알고리즘

## 분류하기

특징에 따라 그래프 상에 표시하고 가장 가까운 이웃이 무엇인지 파악하여 분류할 수 있음

## 특징 추출

거리 구하는 공식은 2차원이던 5차원이던 동일함

계산된 거리가 두 숫자집합 사이의 유사도를 뜻함

```py
math.sqrt((a1 - a2) ** 2 + (b1 - b2) ** 2 + ...))
```

## 회귀 분석

반응을 예측하기

즉, KNN은 그룹으로 나누기(분류)와 반응 예측하기(회귀) 두가지 기능을 함

## 연습문제 10-1

영화평점에 대해 거리 알고리즘으로 A와B의 유사도를 측정하면 가깝지 않게 계산됨

하지만 사실 둘의 취향은 비슷하고 B가 점수를 인색하게 주는 성향이라면 어떻게 해야하나?

정규화를 진행한다.

A와 B의 평균평점을 구한 후 개별 영화에 대한 평점에서 평균평점을 뺀 값으로 유사도를 측정하면 된다

통계시간에 배운 정규화임

# 챕터11.더 공부해야할 것

## 트리

이진 탐색을 사용하는 경우 사용자를 새로 입력할 때마다 배열을 다시 정렬해야하는 문제가 있었다

트리를 사용하면 사용자를 올바른 위치에 넣을 수 있기 때문에 위와 같은 문제를 해소할 수 있다

| |배열|이진탐색트리|
|--|--|--|
|탐색|O(log n)|O(log n)|
|삽입|O(n)|O(log n)|
|삭제|O(n)|O(log n)|

### B-트리

데이터베이스에서 데이터를 저장할 때 흔히 사용됨

## 역 인덱스

주로 검색엔진에서 사용하는 해시 테이블 구조

키 : 단어(검색어)

값 : 웹페이지URL








