# 객체지향 프로그래밍 1

## 객체지향언어

기존의 프로그래밍언어와 다른 새로운 것이 아니라, 몇 가지 새로운 규칙을 추가한 형태임

가장 큰 장점은 코드의 재사용성이 높고 유지보수가 용이하다는 것이다

📌상속,다형성 같은 객체지향개념들은 재사용성,유지보수,중복 코드의 제거 이 세가지 목표를 위한 개념들이라고 생각할 수 있다

### 객체지향 특징
* 추상화
  * 필요한 정보만 뽑아서 간소화함
* 캡슐화
  * 객체의 상태와 기능을 그룹하고 외부에서는 알 수 없게 함
* 상속
  * 기존 클래스에서 약간의 기능만 추가한 클래스를 만든다고 할 때, 상속을 통해 코드 재사용성을 높일 수 있음
* 다형성
  * 조상타입의 참조변수로 자손타입 객체를 참조할 수 있게 함
  * 조상이 같으면 변수에 지정하거나 매개변수로 사용할 수 있음

### 객체 배열

배열의 타입이 객체면 객체배열이다

단, 객체 배열을 생성하는 것은 그저 객체를 다루기 위한 참조변수를 만든 것일 뿐이다 

배열 요소에 new 키워드로 생성한 객체의 주소를 배열에 담아줘야 객체를 생성한 것이다

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/TvTest4.java)

## 변수와 메서드

### 변수

1. 인스턴스변수
* 인스턴스 생성할 때 같이 만들어짐
2. 📌클래스변수
* 변수 앞에 static붙임
* 모든 인스턴스가 공유하는 변수
* 인스턴스를 생성하지 않고도 언제라도 사용할 수 있음
* 클래스가 메모리에 로딩될 때 생성됨
4. 지역변수
* 메서드 내에 선언된 변수로 메서드가 종료되면 소멸됨(반복문도 마찬가지)

### 메서드

입력과 출력이 있는 블랙박스

메서드 사용하면 좋은 점
* 높은 재사용성(reusability)
* 중복된 코드의 제거
* 프로그램의 구조화

메서드의 실행흐름
1. 메서드가 실행되면 지금까지 실행되던 메서드는 실행을 잠시 멈추고 호출된 메서드가 실행된다
2. 호출된 메서드의 실행이 종료되면 다시 호출한 메서드로 돌아와(return) 이후의 문장들이 실행된다

매개변수의 유효성 검사
* 호출하는 쪽에서 매개변수로 아무거나 줄수도 있다
* 메서드는 블랙박스이기 때문에 호출하는쪽은 내부에서 무슨일이 일어나는지 관심도 없고 알 필요도 없다
* 그러므로 메서드 작성자가 가능한 모든 경우의 수를 생각하여 매개변수의 유효성을 검사해야한다

## JVM의 메모리 구조

1.메서드 영역(method area)
  * 클래스에 대한 정보를 저장한다
  * 클래스 변수 즉, static이 붙은 변수도 이곳에 저장된다

2.힙(heap)
  * 인스턴스가 생성되는 공간이다

3.호출스택(call stack)
  * 메서드의 작업에 필요한 지역변수,매개변수 연산의 중간결과 등을 저장한다
  * 메서드가 작업을 마치면 할당되었던 메모리를 반환하고 비워진다
  * 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드다
  * 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드다

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/CallStackTest2.java)

### 기본형 매개변수와 참조형 매개변수

메서드의 매개변수를 참조형으로 선언하면 참조형 객체의 주소값을 매개변수로 보내주는 것이 된다

즉,메서드 호출자의 인자와 메서드의 매개변수가 같은 객체를 참조하게 되어 메서드 내부에서 매개변수의 값을 변경하면 호출자쪽에서도 변경된 것으로 확인이 되는 것이다.

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/ReferenceParamEx.java)

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/ReferenceParamEx3.java)

### 참조형 반환타입

반환형도 참조형으로 사용할 수 있다

반환타입이 참조형이란 것은 메서드가 인스턴스의 주소를 반환한다는 뜻이다

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/ReferenceReturnEx.java)

### 클래스 메서드와 인스턴스 메서드

변수와 마찬가지로 메서드도 클래스 메서드와 인스턴스 메서드가 있다

클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
* 클래스 메서드는 인스턴스 생성없이 호출할 수 있으므로 호출 시점에 인스턴스가 존재하지 않을 수 있다
* 거꾸로인 경우, 인스턴스 메서드에서 클래스 변수를 사용하는 것은 언제나 가능하다

### 📌클래스 멤버와 인스턴스 멤버간의 참조와 호출

클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 할 땐 인스턴스를 생성해야한다.

왜냐하면 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만,클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/MemberCall.java)

## 오버로딩

같은 이름의 메서드에 매개변수의 개수 또는 타입을 다르게하여 메서드를 생성할 수 있다

컴파일러가 메서드를 식별하는 기준은 메서드명 + 매개변수이기 때문이다

또한 반환타입은 식별기준이 아니다

### 가변인자와 오버로딩

```java
타입... 변수명
```

가변인자는 매개변수 중 가장 마지막에 선언해야 한다

가변인자는 내부적으로 배열을 이용하는 것이다

배열을 이용하는 경우, 빈 배열을 매개변수로 넘겨야하는 불편이 있으나 가변인자를 사용하면 인자를 넘겨주지 않거나, 여러개 넘겨주거나, 배열을 넘겨주는 등의 처리가 가능하다

>단, 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 

>왜냐하면 오버로딩한 메서드를 컴파일러가 구분하지 못할 수 있기 때문이다 

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/VarArgsEx.java)

## 생성자

인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다

오해하지 말아야할 부분은 생성자가 인스턴스를 생성하는 것은 아니란 것이다.

이름이 그런거지, 인스턴스를 생성하는 것은 new 연산자이다

* 생성자의 이름은 클래스의 이름과 같아야 한다
* 리턴값이 없다

```java
Card c = new Card();
```
위의 코드를 차례대로 해석하면 아래와 같다.
1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성된다
2. 생성자가 호출된다
3. 연산자 new의 결과로 생성된 Card 인스턴스의 주소가 참조변수 c에 저장된다

### 생성자에서 다른 생성자 호출하지 - this() , this

* 생성자의 이름으로 클래스이름 대신 this를 사용한다
* 한 생성자에서 다른 생성자를 호출할 땐, 반드시 첫줄에서만 호출할 수 있다
> 그 이유는 첫줄이 아니라면 초기화 작업 중 다른 생성자를 호출하여 다시 초기화를 하는 것인데 이럴 경우 이전의 초기화 작업이 무의미해지기 때문이다

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/CarTest2.java)

📌this
* 참조변수로 인스턴스 자신을 가르킨다
* 생성자를 포함한 모든 인스턴스 메서드에는 참조변수 this가 지역변수로 숨겨진 채 존재한다

## 변수의 초기화

멤버변수와 배열의 초기화는 선택적이지만, 지역변수는 꼭 초기화를 해줘야 한다

멤버변수를 초기화하는 방법
1. 명시적 초기화
2. 생성자
3. 초기화 블럭
* 인스턴스 초기화 블럭 : 인스턴스변수를 초기화하는데 사용
* 클래스 초기화 블럭 : 클래스변수를 초기화하는데 사용

### 초기화 블럭

* 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행된다
* 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.
* 그리고 생성자보다 초기화 블럭이 먼저 수행된다

> 📌인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행되어야 할 코드를 넣는데 사용한다
> 결국은 코드의 재사용성과 중복제거가 목표인 것

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/BlockTest.java)

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/StaticBlockTest.java)

### 멤버변수의 초기화 시기와 순서

1. 클래스변수의 초기화시점과 순서 
* 클래스가 처음 로딩될 때 단 한번 초기화된다
* 순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭

2. 인스턴스변수의 초기화시점과 순서
* 인스턴스가 생성될 때마다 인스턴스별로 초기화된다
* 순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자

> 클래스변수는 항상 인스턴스 변수보다 먼저 생성되고 초기화된다.

```java
class InitTest {
  static int cv = 1;    //클래스변수 명시적 초기화 
  int iv = 1;           //인스턴스변수 명시적 초기화
    
  static { cv = 2; }    //클래스변수 초기화 블럭
  { iv = 2; }           //인스턴스변수 초기화블럭
  
  InitTest() {          //생성자
    iv = 3;
  }
}
```
📌위 코드의 초기화 과정
1. cv가 메모리 영역에 생성되고 기본값인 0이 cv에 저장된다
2. 명시적 초기화로 인해 cv에 1이 저장된다
3. 클래스변수 초기화 블럭이 수행되어 cv에 2가 저장된다
4. InitTest클래스의 인스턴스가 생성되며 메모리(heap)에 인스턴스가 존재하게 되며 iv 의 기본값 0 이 저장된다
5. 명시적 초기화로 iv 에 1이 저장된다
6. 인스턴스변수 초기화블럭이 수행되어 iv에 2가 저장된다
7. 생성자가 수행되어 iv에 3이 저장된다

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/ProductTest.java)

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch6/DocumentTest.java)

