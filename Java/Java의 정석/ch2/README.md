>Java의 정석_ch2_변수

# 변수(Variable)

단 하나의 값을 저장할 수 있는 메모리상의 공간

## 1.저장할 수 있는 값의 범위

|자료형|저장 가능한 값의 범위|크기(bit)|
|--|--|--|
|boolean|false,true|8|
|char|0 ~ 2<sup>16</sup> - 1|16|
|byte|-2<sup>7</sup> ~ 2<sup>7</sup> -1|8|
|short|-2<sup>15</sup> ~ 2<sup>15</sup> -1|16|
|int|-2<sup>31</sup> ~ 2<sup>31</sup> -1|32|
|long|-2<sup>63</sup> ~ 2<sup>63</sup> -1|64|

|자료형|저장 가능한 값의 범위|크기(bit)|정밀도|
|--|--|--|--|
|float|1.4E-45 ~ 3.4E38, -1.4E-45 ~ -3.4E38|32|7 자리|
|double|4.9E-324 ~ 1.8E308, -4.9E-324 ~ -1.8E308|64|15 자리|

* 정밀도: 10진수로 n자리까지 오차없이 저장할 수 있다는 뜻

## 2.형식화된 출력 - printf()

지시자를 통해 변수의 값을 여러 가지 형식으로 출력

|지시자|설명|
|--|--|
|%b|boolean으로 출력|
|%d|10진 정수로 출력|
|%o|8진 정수로 출력|
|%x,%X|16진 정수로 출력|
|%f|부동 소수점으로 출력|
|%e,%E|지수 표현식으로 출력|
|%c|문자로 출력|
|%s|문자열로 출력|

[예제1](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/PrintfEx1.java)

[예제2](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/PrintfEx2.java)

## 3.음수의 2진 표현 - 2의 보수법

|#|2진수|부호있는 10진수|
|--|--|--|
|1|0000|0|
|2|0001|1|
|3|0010|2|
|4|0011|3|
|5|0100|4|
|6|0101|5|
|7|0110|6|
|8|0111|최대값 -> 7|
|9|1000|최소값 -> -8|
|10|1001|-7|
|11|1010|-6|
|12|1011|-5|
|13|1100|-4|
|14|1101|-3|
|15|1110|-2|
|16|1111|-1|

### 2의 보수법에 의한 음수 배치를 사용한 이유

절대값이 같은 양수와 음수를 더했을 때 2진수로도 0이 나옴, 즉 컴퓨터의 사칙연산이 편리해짐

### 2의 보수?

n의 보수 : 어떤 수에 더했을 때 n이 되는 수를 말함
즉, 2의 보수는 더했을 때 2가 되는 수를 찾으라는 뜻
그리고 이진법에서 2의 보수는 더했을 때 자리올림이 발생하고 해당 자리가 0 이 되도록 만드는 수를 이야기함
예를 들어, 10진수에서 3의 보수는 7, 6의 보수는 4 임

### 2의 보수 구하기

📌2의 보수 = 1의 보수 + 1 

* 1의 보수 => 원래있던 이진수의 0을 1로, 1을 0으로 바꾼 수

> 왜 1의 보수 + 1 이 2의 보수일까?
> 어떤 이진수가 있을 때 그 수에 1의 보수를 더하면 모든 자리가 1인 수가 된다 
> 그 수에 +1 을 더하면 모든 자리가 0이 되고 가장 큰 자리는 1이 되지만 자릿수를 넘어가 버리게 됨

* 1010 + 1111 = 1111
* 1111 + 0001 = 10000(맨 앞의 1은 버려짐)

## 4.기본자료형(primitive type)

### char : 특수문자

역슬래시(\) 와 조합하여 사용함

|특수문자|문자 리터럴|
|--|--|
|tab|\t|
|backspace|\b|
|new line|\n|
|carriage return|\r|
|역슬래시(\)|\\|
|작은따옴표|\'|
|큰따옴표|\"|
|유니코드문자|\u 유니코드|

```java
//유니코드 문자 예
char a = '\u0041'
```
[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/SpecialCharEx.java)

### char에 그냥 정수가 저장되는 것이라면 컴퓨터는 어떻게 'A' 와 65를 구분하여 출력할수 있을까?

* 컴퓨터는 그 변수의 값만이 아니라 타입까지 함께 해석한다

>char ch = 'A';
>short s = 65;
>ch와 s 모두 65에 해당하는 이진수값이 해당 변수에 저장된다
>하지만 println() 으로 출력하면 ch는 'A', s는 65를 보여준다
>왜냐하면 자료형이 다르기 때문이다
>즉,컴파일러가 어떤 값을 해석할 때 자료형과 값 둘을 모두 알아야 올바른 해석을 할 수 있다.

### 정수형 선택하기

int 가 제일 좋다.
왜냐하면 JVM의 피연산자 스택이 4 byte 단위로 저장하기 때문에 byte 나 short을 선택할 경우엔 4 byte로 변환하는 연산을 따로 수행하게 되어 오히려 효율이 떨어지게 된다
byte나 short은 성능보다는 저장공간을 절약하는 것이 더 중요할 때 사용한다

### 부호있는 정수의 오버플로우

|부호없는10진수|2진수|부호있는 10진수|
|--|--|--|
|0|0000|0|
|1|0001|1|
|2|0010|2|
|3|0011|3|
|4|0100|4|
|5|0101|5|
|6|0110|6|
|7|0111|7 <- 최대값|
|8|1000|-8 <- 최소값|
|9|1001|-7|
|10|1010|-6|
|11|1011|-5|
|12|1100|-4|
|13|1101|-3|
|14|1110|-2|
|15 <- 최대값|1111|-1|
|0 <- 최소값|0000|0|

>부호없는 정수의 오버플로우 -> 모든 자릿수가 1인 상태에서 +1 하면서 0000으로 바뀌게 되고 정수 0으로 해석됨
>부호있는 정수의 오버플로우 -> 가장 첫번째 자릿수가 0 에서 1로 바뀔 때 정수 최대값에서 최소값으로 오버플로우됨

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/OverflowEx.java)

### 실수형 - 표현과 저장

부호(S),지수(E),가수(M)

+-M * 2<sup>E</sup>

* float타입

|S(1)|E(8)|M(23)|
|--|--|--|

* double타입

|S(1)|E(11)|M(52)|
|--|--|--|

### 실수형 - 정밀도

정밀도가 7이라면 7자리의 10진수를 오차없이 저장할 수 있다는 뜻임
>1234.567 = 1.234567 * 10<sup>3</sup>
>0.001234567 = 1.234567 * 10<sup>-3</sup>
>1234567000 = 1.234567 * 10<sup>9</sup>

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/FloatEx1.java)

### 부동소수점의 오차

가수를 저장할 수 있는 자리수가 한정되어 있어 그 자리수를 넘어가는 가수부는 반올림하게 되어있다.
(float의 경우 가수부 24번째 자리가 1이면 23번째 자리에서 반올림)

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/FloatToBinEx.java)

### 정수형과 실수형 간의 형변환

float의 정밀도가 7이기 때문에 10진수로 8자리 이상(천만)의 정수를 실수로 변환할 땐 float이 아닌 double로 변환해야 오차가 발생하지 않는다.

[예제](https://github.com/jjy3385/StandardOfJava/blob/main/src/ch2/CastingEx4.java)

### 자동형변환

기본자료형끼리는 자동형변환이 가능하다

값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다

값손실이 없는 형변환이기 때문에 문제없이 형변환 가능
