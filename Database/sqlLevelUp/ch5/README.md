# 5장. 반복문

SQL은 절차 지향적인 사고방식이 아니라 집합 지향적인 사고방식으로 문제를 해결해야함

반복은 대표적인 절차 지향적 사고방식이고 가장 먼저 떠오르는 해법이기도 함

쓸데없는 반복을 줄여야함

## 14강. 반복문 의존증

### SQL에 반복문이 없는 이유?

관계 조작이 목적인 SQL에서는 반복을 제외하는 것이 편하다고 생각했기 때문이라고함

어쨋든 SQL은 집합적인 형태로 한꺼번에 여러 행을 처리할 수 있음

업무에서 선배들이 왠만하면 CURSOR 쓰지말라고 한 이유에 이런 의미가 깔려있었음

(누구도 설명해주진 않았지만...)

CURSOR 는 대표적으로 레코드 하나하나 처리하는 방식임

이런 반복계 쿼리를 작성하는 것보다 포장계(한번에 처리)하는 쿼리를 작성하는게 좋음

그 이유는 다음과 같음

1. 반복계 쿼리는 성능향상의 여지가 적음

   즉, 간단한 처리를 여러번 하기 때문에 시간복잡도가 O(N) 그래프가 됨

   하지만 포장계는 O(logN)형태임

2. SQL 실행의 오버헤드

   ##### SQL 전처리 과정

   1) SQL 구문을 네트워크로 전송

   2) 데이터베이스 연결

   3) SQL 구문 파스

   4) SQL 구문의 실행 계획 생성 또는 평가

   ##### 후처리

   5) 결과집합을 네트워크로 전송

   위의 전처리와 후처리 과정 모두가 오버헤드임
   오버헤드는 SQL을 실행하는 어플리케이션과 DBMS 간의 일종의 계약이라고 할 수 있음

   계약건마다 각종 비용이 들어가게 되는데 작은 계약을 여러번 맺는것보다는 큰 계약 한건 따는게  수익성에 훨씬 좋은것과 같은 이치로 반복계 코드는 일정한 오버헤드를 지속적으로 발생시키기 때문에 성능면에서 효율적이지 못함

3. 병렬 분산이 힘듬

4. 데이터베이스의 진화로 인한 혜택을 받기 힘듬

아무튼 위와 같은 이유로 SQL은 반복계 코드보다는 포장계 코드로 작성해줘야됨

근데 배운게 반복이라 무의식적으로 그것만 쓰는 경우가 많음

#### 반복계의 장점

1. 반복계 코드는 실행계획이 안정적임

   비교적 단순한 쿼리를 반복수행하니까....

2. 처리시간 예상하기 쉬움

>  1회 실행시간 * 실행 회수 = 예상 시간 

3. 트랜잭션 제어가 편리

   포장계는 갱신 처리 중간에 오류가 발생하면 처음부터 다시 처리해야되지만 반복계는 어디까지 진행됐는지 살펴보고 다시 시작하면 됨

## 16강. SQL에서 반복을 어떻게 표현할까?

### 1. 포인트는 CASE 식과 윈도우 함수

```mssql
SELECT company,
       year,
	   sale,
	   CASE SIGN(sale - MAX(sale) OVER(PARTITION BY company
									   ORDER BY year
									   ROWS BETWEEN 1 PRECEDING
									            AND 1 PRECEDING))
			WHEN 0 THEN '='
			WHEN 1 THEN '+'
			WHEN -1 THEN '-'
			ELSE NULL END AS var 
  FROM Sales
```

윈도우 함수에 `ROWS BETWEEN` 옵션을 사용하여 대상 범위의 레코드를 직전의 1개로 제한하는 처리를 할 수 있음

즉 `ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING` 은 '현재 레코드에서 1개 이전부터 1개 이전까지의 레코드 범위' 를 나타냄

> PARTITION BY 가 레코드를 자르는 기능이 있다고 했었다
>
> company 필드 기준으로 레코드를 자르고 year 로 정렬하고 그 각 레코드에 대한 범위를 설정해준 처리
>
> 📌익숙한 구문은 아니지만 가장 중요한 것은 레코드 단위로 근접한 레코드를 범위로 설정해줄 수 있다는 것

