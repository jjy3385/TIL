# DBMS 아키텍처

## 1강. DBMS 아키텍처 개요

### 📌쿼리 평가 엔진

사용자로부터 입력받은 SQP 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정한다

이때, 결정되는 계획을 **실행계획**이라고 한다.

이러한 실행계획에 기반을 둬서 데이터에 접근하는 방법을 **접근 메서드**라고 한다.

### 📌버퍼 매니저

DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해둔다

이 메모리 영역을 관리하는 것이 바로 버퍼 매니저다

### 디스크 용량 매니저

어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어한다

### 트랜잭션 매니저와 락 매니저

일반적으로 여러 사람이 동시에 데이터베이스를 접근/사용한다

이 때, 각각의 처리는 트랜잭션이라는 단위로 관리된다

데이터의 정합성을 유지하면서 트랜잭션을 실행시키고, 

필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는것이 트랜잭션 매니저와 락 매니저의 역할이다.

### 리커버리 매니저

시스템은 언제나 장애가 발생할 수 있기 때문에 데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구해줘야 한다

이런 기능을 수행하는 것이 리커버리 매니저이다.



어쨋거나 성능이라는 관점에서 가장 중요한 것은 **쿼리평가 엔진**(혹은 쿼리평가 엔진이 세우는 실행계획)이다.

또한 버퍼 매니저도 성능과 밀접한 관계가 있다.

## 2강. DBMS와 버퍼

### 기억장치의 분류와 트레이드오프

접근 속도가 빠를수록 기억비용도 높다

즉, 빠르면 비싸서 용량이 적다

|           | 1차 기억장치       | 2차 기억장치                | 3차 기억장치(?) |
| --------- | ------------------ | --------------------------- | --------------- |
| 기억장치  | 레지스터,메모리 등 | HDD,CD,DVD,플래시 메모리 등 | 테이프 등       |
| 접근 속도 | 빠름               | 중간                        | 느림            |
| 기억 비용 | 높음               | 중간                        | 낮음            |

### DBMS와 기억장치의 관계

DBMS는 데이터 저장이 목적이다

DBMS가 사용하는 대표적인 기억장치는 **하드디스크(HDD)** 와 **메모리**이다

#### 하드디스크

DBMS의 데이터 저장소는 대부분 하드디스크다

왜냐하면 그냥 제일 무난하기 때문임

#### 메모리

메모리는 디스크에 비해 기억 비용이 굉장히 비싸다

따라서 상용 시스템의 데이터베이스 내부 데이터를 모두 메모리에 올리는 것은 불가능하다

#### 버퍼를 활용한 속도 향상

자주 접근하는 데이터를 메모리 위에 올려둔다

그러면 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터를 검색할 수 있게 된다

SQL 구문의 실행 시간 대부분은 저장소 I/O에 사용된다

따라서 디스크 접근을 줄이는 이런 방식은 굉장한 성능 향상을 가능하게 한다

이렇게 **성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼 또는 캐시**라고 한다

> 버퍼는 완중체라는 뜻이다

이러한 고속 접근이 가능한 버퍼에 데이터를 어떻게, 어느 정도의 기간 동안 올릴지를 관리하는 것이 DBMS의 버퍼 매니저이다

### 메모리 위에 있는 두개의 버퍼

* #### 데이터 캐시

  디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역

* #### 로그 버퍼

  갱신 처리(INSERT,DELETE,UPDATE,MERGE) 와 관련됨

  DBMS는 갱신과 관련된 SQL구문을 사용자로부터 입력받으면, 곧바로 저장소에 있는 데이터를 변경하지 않는다

  📌로그 버퍼 위에 변경 정보를 보내고 COMMIT 때 메모리로부터 디스크로 정보를 복사한다

  이렇게 하는 이유도 결국은 성능향상을 위해서이다.

  데이터 갱신도 디스크에 접근하는 것이라 상당한 시간이 소모되기 때문에 바로 변경하진 않고 로그 버퍼에 올려뒀다 나중에 처리한다

### 메모리의 성질이 초래하는 트레이드오프

* #### 휘발성

  메모리의 데이터는 영속성이 없다

  결국 메모리가 디스크를 완전히 대체하는 것은 불가능하다

* #### 휘발성의 문제점

  가장 큰 문제는 장애가 발생했을 때 데이터의 부정합을 발생시키는 것이다

  로그 버퍼 위에 존재하는 데이터가 디스크에 있는 로그 파일에 반영되기 전에 장애가 발생한다면 해당 데이터가 완전히 사라져서 복구가 불가능해진다

  이런 문제는 DMBS가 갱신을 비동기로 하는 이상, 언제든 발생할 수 있는 문제이다

  따라서 이를 회피하고자 커밋 시점에 반드시 갱신 정보를 로그 파일에 쓸 수도 있다(로그버퍼에 올리자마자 디스크에 반영한다)

  이렇게 하면 자주 커밋을 하게 되고 그때마다 디스크에 동기 접근이 일어나 성능이 느려질 수 있다

  #### - 데이터 정합성과 성능의 트레이드 오프

  | 이름        | 데이터 정합성 | 성능 |
  | ----------- | ------------- | ---- |
  | 동기 처리   | O             | X    |
  | 비동기 처리 | X             | O    |

### 시스템 특성에 따른 트레이드오프

데이터베이스는 기본적으로 검색을 메인으로 처리한다고 가정하기 때문에 로그 버퍼의 크기는 초깃값이 굉장히 작다.

로그 버퍼를 크게 잡는다면, 갱신 처리와 관련된 부하가 클 것을 고려한 설계인 것이다.

데이터 캐시가 크면 검색이 중심인 시스템 설계 로그 버퍼가 크면 갱신이 중심인 시스템 설계라고 할 수 있다.

### 추가적인 메모리 영역 '워킹 메모리'

정렬 또는 해시 관련 처리에 사용되는 작업용 메모리 영역

정렬은 ORDER BY 구,집합 연산,윈도우 함수 등의 기능을 사용할 때 실행됨

바면, 해시는 주로 테이블의 결합에서 해시 결합을 사용할 때 실행됨

데이터 양이 늘어서 메모리에 다 들어가지 않으면 저장소를 사용한다(MSSQL 에서는 TEMPDB)

(이게 OS의 스왑같은 것이라고 함)

## 3강. DBMS와 실행계획

## 4강. 실행계획이 SQL 구문의 성능을 결정

## 5강. 실행계획의 중요성
