# DBMS 아키텍처

## 1강. DBMS 아키텍처 개요

### 📌쿼리 평가 엔진

사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정한다

이때, 결정되는 계획을 **실행계획**이라고 한다.

이러한 실행계획에 기반을 둔 데이터접근 방법을 **접근 메서드**라고 한다.

### 📌버퍼 매니저

DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해둔다

이 메모리 영역을 관리하는 것이 바로 버퍼 매니저다

### 디스크 용량 매니저

어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어한다

### 트랜잭션 매니저와 락 매니저

일반적으로 여러 사람이 동시에 데이터베이스를 접근/사용한다

이 때, 각각의 처리는 트랜잭션이라는 단위로 관리된다

데이터의 정합성을 유지하면서 트랜잭션을 실행시키고, 

필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는것이 트랜잭션 매니저와 락 매니저의 역할이다.

### 리커버리 매니저

시스템은 언제나 장애가 발생할 수 있기 때문에 데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구해줘야 한다

이런 기능을 수행하는 것이 리커버리 매니저이다.

어쨋거나 성능이라는 관점에서 가장 중요한 것은 **쿼리평가 엔진**(혹은 쿼리평가 엔진이 세우는 실행계획)이다.

또한 버퍼 매니저도 성능과 밀접한 관계가 있다.

## 2강. DBMS와 버퍼

### 기억장치의 분류와 트레이드오프

접근 속도가 빠를수록 기억비용도 높다

즉, 빠르면 비싸서 용량이 적다

|           | 1차 기억장치       | 2차 기억장치                | 3차 기억장치(?) |
| --------- | ------------------ | --------------------------- | --------------- |
| 기억장치  | 레지스터,메모리 등 | HDD,CD,DVD,플래시 메모리 등 | 테이프 등       |
| 접근 속도 | 빠름               | 중간                        | 느림            |
| 기억 비용 | 높음               | 중간                        | 낮음            |

### DBMS와 기억장치의 관계

DBMS는 데이터 저장이 목적이다

DBMS가 사용하는 대표적인 기억장치는 **하드디스크(HDD)** 와 **메모리**이다

#### 하드디스크

DBMS의 데이터 저장소는 대부분 하드디스크다

왜냐하면 그냥 제일 무난하기 때문임

#### 메모리

메모리는 디스크에 비해 기억 비용이 굉장히 비싸다

따라서 상용 시스템의 데이터베이스 내부 데이터를 모두 메모리에 올리는 것은 불가능하다

#### 버퍼를 활용한 속도 향상

자주 접근하는 데이터를 메모리 위에 올려둔다

그러면 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터를 검색할 수 있게 된다

SQL 구문의 실행 시간 대부분은 저장소 I/O에 사용된다

따라서 디스크 접근을 줄이는 이런 방식은 굉장한 성능 향상을 가능하게 한다

이렇게 **성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼 또는 캐시**라고 한다

> 버퍼는 완중체라는 뜻이다

이러한 고속 접근이 가능한 버퍼에 데이터를 어떻게, 어느 정도의 기간 동안 올릴지를 관리하는 것이 DBMS의 버퍼 매니저이다

### 메모리 위에 있는 두개의 버퍼

* #### 데이터 캐시

  디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역

* #### 로그 버퍼

  갱신 처리(INSERT,DELETE,UPDATE,MERGE) 와 관련됨

  DBMS는 갱신과 관련된 SQL구문을 사용자로부터 입력받으면, 곧바로 저장소에 있는 데이터를 변경하지 않는다

  📌로그 버퍼 위에 변경 정보를 보내고 COMMIT 때 메모리로부터 디스크로 정보를 복사한다

  이렇게 하는 이유도 결국은 성능향상을 위해서이다.

  데이터 갱신도 디스크에 접근하는 것이라 상당한 시간이 소모되기 때문에 바로 변경하진 않고 로그 버퍼에 올려뒀다 나중에 처리한다

### 메모리의 성질이 초래하는 트레이드오프

* #### 휘발성

  메모리의 데이터는 영속성이 없다

  결국 메모리가 디스크를 완전히 대체하는 것은 불가능하다

* #### 휘발성의 문제점

  가장 큰 문제는 장애가 발생했을 때 데이터의 부정합을 발생시키는 것이다

  로그 버퍼 위에 존재하는 데이터가 디스크에 있는 로그 파일에 반영되기 전에 장애가 발생한다면 해당 데이터가 완전히 사라져서 복구가 불가능해진다

  이런 문제는 DMBS가 갱신을 비동기로 하는 이상, 언제든 발생할 수 있는 문제이다

  따라서 이를 회피하고자 커밋 시점에 반드시 갱신 정보를 로그 파일에 쓸 수도 있다(로그버퍼에 올리자마자 디스크에 반영한다)

  이렇게 하면 자주 커밋을 하게 되고 그때마다 디스크에 동기 접근이 일어나 성능이 느려질 수 있다

  #### - 데이터 정합성과 성능의 트레이드 오프

  | 이름        | 데이터 정합성 | 성능 |
  | ----------- | ------------- | ---- |
  | 동기 처리   | O             | X    |
  | 비동기 처리 | X             | O    |

### 시스템 특성에 따른 트레이드오프

데이터베이스는 기본적으로 검색을 메인으로 처리한다고 가정하기 때문에 로그 버퍼의 크기는 초깃값이 굉장히 작다.

로그 버퍼를 크게 잡는다면, 갱신 처리와 관련된 부하가 클 것을 고려한 설계인 것이다.

데이터 캐시가 크면 검색이 중심인 시스템 설계 로그 버퍼가 크면 갱신이 중심인 시스템 설계라고 할 수 있다.

### 추가적인 메모리 영역 '워킹 메모리'

정렬 또는 해시 관련 처리에 사용되는 작업용 메모리 영역

정렬은 ORDER BY 구,집합 연산,윈도우 함수 등의 기능을 사용할 때 실행됨

바면, 해시는 주로 테이블의 결합에서 해시 결합을 사용할 때 실행됨

데이터 양이 늘어서 메모리에 다 들어가지 않으면 저장소를 사용한다(MSSQL 에서는 TEMPDB)

(이게 OS의 스왑같은 것이라고 함)

## 3강. DBMS와 실행계획

### 권한 이양

C,자바같은 절차가 기초가 되는 언어는 사용자가 데이터에 접근하기 위한 절차(How)를 책임지고 기술하는 것이 전제인 반면

비절차적인 RDB는 그러한 모든 일을 사용자가 아닌 시스템(쿼리 평가 엔진)에 맡겼다

그 목적은 비즈니스 전체의 생산성 향상의 추구이다.

하지만 역설적으로 RDB가 숨기고 있는 내부 절차를 들여다봐야 성능 문제를 다룰 수 있다.

### 데이터에 접근하는 방법은 어떻게 결정될까?

RDB의 데이터 접근 절차는 쿼리 평가 엔진이 결정한다.

### 📌쿼리 처리 흐름

1. #### 파서

   사용자로부터 입력받은 SQL 구문을 검사해준다(구문오류 검사)

2. #### 옵티마이저

   📌데이터 접근법을 최적화한다(실행계획)

   어떤 쿼리에서 정의한 데이터로의 접근법이 하나만 있는 것이 아니기 때문에 여러가지 고려사항에 따라 실행계획을 작성하고 이들의 비용을 연산한 후 가장 비용이 낮은 시행계획을 선택하는 일을 한다.

   다른 언어에서는 사람이 할일을 옵티마이저가 대신 해준다고 생각할 수 있다.

   (고려사항 : 인덱스 유무,데이터 분산 또는 편향 정도,DBMS 내부 매개변수 등)

3. #### 카탈로그 매니저

   옵티마이저가 실행 계획을 세울 때 중요한 정보를 제공하는 역할을 한다

   카탈로그란 DBMS의 내부 정보를 모아놓은 테이블들로, 테이블 또는 인덱스 **통계 정보**가 저장되어 있다.

   즉, 옵티마이저에게 통계정보를 제공하는 역할을 한다.

4. #### 플랜 평가

   옵티마이저가 SQL 구문에서 여러 실행계획을 세운 뒤 그것을 받아 최적의 실행 계획을 선택하는 것이 플랜 평가이다

### 옵티마이저와 통계 정보

데이터베이스 엔지니어는 통계 정보 관리에 항상 신경을 써줘야 한다

통계정보가 부족한 경우, 옵티마이저가 최적의 플랜을 선택하지 못할 가능성이 높아지기 때문이다.

>  카탈로그에 포함되어 있는 통계 정보
>
> * 각 테이블의 레코드 수
> * 각 테이블의 필드 수와 필드의 크기
> * 필드의 카디널리티(값의 개수)
> * 필드값의 히스토그램(분포도)
> * 필드 내부의 NULL 수
> * 인덱스 정보

이러한 정보들이 테이블 또는 인덱스의 실제와 일치하지 않았을 때 문제가 생길 수 있다

### 최적의 실행 계획이 작성 되게 하려면...

테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다

이건 상식이다

#### 통계정보 갱신 명령어(MSSQL)

```mssql
UPDATE STATISTICS [테이블이름]

```



## 4강. 실행계획이 SQL 구문의 성능을 결정



### 실행계획 확인 방법

MSSQL 에선 `SET SHOWPLAN_TEXT ON` 명령어를 쓰거나 SSMS에서 실행계획 표시 버튼을 클릭하면 실행계획을 볼 수 있다. 

### 1. 테이블 풀 스캔의 실행 계획

```mssql
SELECT * 
  FROM Shops
```

![](https://github.com/jjy3385/TIL/blob/main/Database/sqlLevelUp/ch1/image/tableScan.png)

#### 📌가장 중요한 확인사항

* ##### 조작대상 객체

* ##### 객체에 대한 조작의 종류

* ##### 조작 대상이 되는 레코드 수

#### 조작대상 객체

가장 마지막에 개체 `[SQLLevelUp].[dbo].[Shops]`

#### 객체에 대한 조작의 종류

물리적 연산과 논리적 연산에 테이블 스캔

즉, 테이블을 순차적으로 스캔하면서 레코드에 접근하고 있다는 뜻

> 물리적 연산과 논리적 연산이 어떤 차이가 있는지는 잘 모르겠음

#### 조작 대상이 되는 레코드 

데이터양에 따라 함수적으로 처리 비용이 늘어난다

대표적으로 테이블 스캔은 O(N) 의 시간복잡도를 갖지만  인덱스 스캔은 O(logN)의 시간복잡도를 갖는다

> 📌인덱스는 이진트리 자료구조를 사용하기 때문인 것으로 알다
>
> 정확한 구현에 대해선 좀 더 스터디가 필요함

### 2. 인덱스 스캔의 실행 계획

기존 Shops 테이블에 `shop_id` 를 Primary Key를 추가하였다.

![](https://github.com/jjy3385/TIL/blob/main/Database/sqlLevelUp/ch1/image/indexScan.png)

조작대상 객체,객체에 대한 조작의 종류가 바뀌었다.

#### 조작대상 객체

`Shops` 테이블에서 `[Shops].[PK_Shops]` 인덱스로 바뀌었다

#### 객체에 대한 조작의 종류

인덱스 스캔으로 바뀐것을 확인할 수 있다(일단 클러스터드는 신경쓰지 말자)

#### 조작의 대상이 되는 레코드 수

똑같이 5개다

```mssql
SELECT *
  FROM Shops
 WHERE shop_id = '00001'
```

위와 같이 `where` 절을 작성하면 조작의 대상이 되는 레코드 수가 하나로 줄어든다.

위의 경우엔 `PK_Shops` 인덱스에서 `shop_id = '00001'` 인 건을 찾은 후에 이 건과 바로 맵핑되는 테이블 레코드를 찾아내는 방식으로 작동한다

위에서 설명한대로 시간복잡도가 O(logN)이므로 테이블 스캔보다 데이터양에 따른 민감도가 적다

### 3. 간단한 테이블 결합의 실행 계획

SQL에서 지연이 일어나는 경우는 대부분 결합(JOIN) 과 관련된 것이다

결합을 사용하면 실행 계획이 대단히 복잡해진다

```mssql
SELECT * 
  FROM Shops AS A
  JOIN Reservations AS B 
    ON A.shop_id = B.shop_id
```

```mssql
-- StmtText  
|--Nested Loops(Inner Join, OUTER REFERENCES:([B].[shop_id]))
   |--Clustered Index Scan(OBJECT:([SQLLevelUp].[dbo].[Reservations].[PK_Reservations] AS [B]))
   |--Clustered Index Seek(OBJECT:([SQLLevelUp].[dbo].[Shops].[PK_Shops] AS [A]), SEEK:([A].[shop_id]=[SQLLevelUp].[dbo].[Reservations].[shop_id] as [B].[shop_id]) ORDERED FORWARD)
```

![](https://github.com/jjy3385/TIL/blob/main/Database/sqlLevelUp/ch1/image/join.png)

#### 조작 대상 객체

PK_Reservations,PK_shops

#### 객체에 대한 조작의 종류

📌중첩 루프(Nested Loops) : 가장 기본적인 결합 알고리즘

한쪽 테이블에서 레코드 하나마다 결합조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식으로 이중 반복으로 구현되었다.

시간복잡도가 O(N^2)

#### 실행계획을 읽는 방법 

1. 실행계획은 일반적으로 트리 구조로 되어 있다
2. 중첩 단계가 깊을수록 먼저 수행된다

위의 두 방법을 유념해서 실행계획을 해석해보면 먼저 `Shops.PK_Shops`인덱스 검색(Index Seek)이 이뤄진 것을 알 수 있다.

그 후 결합조건에 의해 `Reservations.PK_Reservations`인덱스 스캔(Index Scan)이 이뤄진다

후에 결합에서 다시 설명하겠지만 `Shops` 가 구동테이블(외부테이블) `Reservations`가 내부테이블이다

(먼저 접근하는 테이블이 구동테이블이 된다)

그렇게 각 테이블 인덱스를 통해 테이블에 대한 접근을 먼저 수행한 후 중첩 루프가 수행된다

 (SSMS UI보다 StmtText가 더 보기 편한거 같다...실행계획이 복잡해질수록 더 그렇다....)

## 5강. 실행계획의 중요성

옵티마이저는 꽤나 우수하지만 완벽하진 못하다

옵티마이저가 실수할 때 최후의 방법으로  수동으로 실행계획을 변경해주는 것이 데이터베이스 엔지니어의 일이라고 볼 수 있다

이런 작업들을 하기 위해서 먼저 아래의 사항들을 알아야한다.

1. SQL 구문과 그러한 SQL 구문들이 어떠한 접근 경로(access path)로 데이터를 검색하는지
2. 제대로 된 SQL구문을 작성하려면 어떤 테이블 설정이 효율적인지
3. 어떤 SQL구문이 주어졌을 때 어떠한 실행계획이 나올지(예측)
