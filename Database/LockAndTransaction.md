# Lock과 트랜잭션 동시성 제어

> 그 동안 SQL을 사용하면서 Lock과 트랜잭션에 대해 정리한 적은 없었다.
> 
> 실제 업무에서 신경쓸 일이 별로 없었고 그냥 데드락 있으면 세션Kill했었다.
> 
> 내 파트에선 사용자가 동시에 같은 데이터를 수정하는 일이 적고 트랜잭션도 대부분 짦았기 때문인듯....
> 
> 어쨋든 이제 개념을 정리해보고 업무에 적용해보려고 한다.

## 1.Lock

트랜잭션의 순차적 진행을 보장해주는 직렬화 장치

예를 들어, 영화관 좌석 하나를 두명이 동시에 요청을 할 때 한명만 예약이 될 수 있도록 해야하는데 이때 DBMS가 사용하는 메커니즘이 Lock이다

### 공유Lock과 배타적Lock

> DBMS마다 그 이름의 세부적인 차이가 있지만 개념만 알면 됨

#### 공유Lock

📌데이터를 읽고자 할 때 사용되는 Lock

다른 공유 Lock고 호환되지만 배타적 Lock과는 호환되지 않음

> 호환된다는 건 한 리소스를 두 개 이상의 Lock을 동시에 설정할 수 있다는 뜻

#### 배타적Lock(Exclusive Lock)

📌데이터를 변경하고자 할 때 사용되는 Lock

트랜잭션이 완료될 때까지 유지되며 다른 트랜잭션은 해당 리소스에 접근할 수 없음

### 블로킹과 교착상태

#### 블로킹

Lock 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태임

예를 들어, 어떤 레코드에 `UPDATE` 트랜잭션이 진행되고 있으면 `SELECT` 트랜잭션은 `UPDATE` 트랜잭션이 멈춰있음

> 데이터 변경할 때 배타적 Lock이므로 데이터를 읽는 공유Lock은 해당 리소스에 접근할 수 없음

위와 같은 요인으로 인해 Lock에 의한 성능저하가 발생하며 그것을 최소화하려는 노력이 필요

> 성능저하 최소화 방안
>
> 1. 트랜잭션의 원자성을 훼손하지 않는 선에서 트랜잭션을 가능한 짧게 정의하려고 노력해야함
>
> 2. 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계(특히 트랜잭션이 활발한 주간 시간대에)
>
> 3. 대용량 갱신 작업이 불가피하다면, 블로킹 현상에 의해 사용자가 무한정 기다리지 않도록 적절한 프로그래밍 기법을 도입해야함
>
>    `LOCK_TIMEOUT` 또는 `for update wait` 같은 구문 활용
>
> 4. 트랜잭션 격리성 수준을 불필요하게 상향조정하지 않는다.
>
> 5. SQL문장이 가장 빠른 시간 내에 처리를 완료하도록 한다
>
>    이것이 Lock 튜닝의 기본이고 효과도 가장 좋다.

#### 교착상태(DeadLock)

📌두 세션이 각각 Lock 설정한 리소스를 서로 액세사하려고 마주보며 진행하는 상황으로 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없다.

개발자는 교착상태를 방지하는게 최우선 과제임

1. 트랜잭션 진행방향을 같은 방향으로 처리

   예를 들어, 트랜잭션1에서 A 갱신 후 B 갱신하는 처리 방향을 갖고 있다면 트랜잭션2도 같은 방향으로 처리

2. 트랜잭션 처리속도를 최소화(성능향상)

   트랜잭션을 가능한 짧게 정의할수록 교착상태에 빠질 확률이 낮아짐

> 블로킹과 교착상태를 최소화하는 방안
>
> 제일 중요한건 케이스마다 해결책이 다르긴 하지만 쿼리 하나하나의 성능이 빠를수록 좋다는 것이다

## 2.트랜잭션

업무처리를 위한 논리적 작업 단위

예를 들어, 처리할 업무가 송금이라고 하면 `A 계좌의 금액을 줄인다` 와 `B계좌의 금액을 늘린다` 가 하나의 논리적 작업 단위로 묶임

둘 중 하나만 처리되면 안되고 둘다 되거나 둘다 안되도록(All or nothing) 해야함

그러므로 트랜잭션은 여러 연산을 하나로 묶는 것이라고 할 수 있음

### 트랜잭션 특징

ACID

* 원자성(Atomicity) 
  * 트랜잭션은 더 이상 분해할 수 없는 업무의 최소단위이므로 전부 처리되거나 하나도 처리되지 않아야함.
* 일관성(Consistency)
  * 처리 전 후 데이터 일관성이 유지되어야 한다.
* 격리성(Isolation)
  * 실행 중인 트랜잭션 중간 결과에 다른 트랜잭션이 접근할 수 없다.
* 영속성(Durability)
  * 트랜잭션이 성공적으로 수행되면 그 결과는 데이터베이스에 영원히 저장됨

### 트랜잭션의 격리성

Lock을 강하게 오래 유지할수록 트랜잭션의 격리성이 높아지며 Lock을 최소화할수록 낮아짐

#### 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들

* Dirty Read

  * 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것

* Non-Repeatable Read

  * 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 **값을 수정 또는 삭제**하는 바람에 두 쿼리의 결과가 다르게 나타나는 현상

* Phantom Read

  * 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 첫 번째 쿼리에 없던 유령 레코드가 두번째 쿼리에 나타나는 현상

    즉,두 쿼리 사이에 다른 트랜잭션에서 레코드를 입력하는 경우

#### 트랜잭션 격리성 수준

* Read Umcommitted
  * 트랜잭션에서 처리중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
* Read Commiited(기본설정)
  * 트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션에서 읽도록 허용함
  * **Dirty Read** 까지 방지
* Repeatable Read
  * 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 변경되는 것을 방지
  * **Non-Repeatable Read** 까지 방지
* Serializable Read
  * 트랜잭션 내에서 쿼리를 두번 이상 수행할 때, 새로운 레코드가 나타자지 않음
  * Phantom Read 까지 방지

> 아래로 내려갈수록 트랜잭션 격리성 수준이 높아지고, 격리성 수준이 낮을 때 발생하는 현상을 더 많이 커버하게 됨

대부분 DBMS 기본설정은 Read Commited 이므로 Dirty Read 까지는 발생하지 않지만 Non-Repeatable Read 나 Phantom Read 현상은 발생함

따라서 두 현상에 대한 주의가 필요함

#### 📌다중버전 동시성 제어(Muttiversion Concurrency Control,MVCC)

격리성을 Serializable Read 수준을 기본설정으로 하여 사용할수도 있음

하지만 그렇게  하면 대량의 데이터를 갱신할때는 동시성이 심각하게 나빠질 수 있음

이러한 문제의 대안으로 나온게 '스냅샷 격리성 수준'임

* Snapshot Isolation Level
  * 트랜잭션 내 모든 쿼리가 트랜잭션 시작 시점의 버전(스냅샷)을 본다는 뜻
  * 즉 한 트랜잭션 내에서 같은 쿼리 수행 중간에 다른 트랜잭션이 새로운 레코드를 입력했더라도 트랜잭션 시작 시점의 버전이 기준이므로 새로운 레코드는 무시됨

## 동시성 제어

다중 트랜잭션의 상호 간섭 작용에서 데이터베이스를 보호하는 것

Lock을 통해 트랜잭션을 직렬화하는 것이 핵심임

동시성과 일관성은 트레이드오프 관계임

따라서 동시성 제어의 목표는 동시에 실행되는 트랜잭션의 수를 최대화하면서도 데이터 무결성이 유지되도록 하는 것이다

### 비관적 동시성 제어와 낙관적 동시성 제어

#### 비관적 동시성 제어(Pessimistic Concurrency Control,PCC)

사용자들이 같은 데이터를 동시에 수정할 것이라고 가정함

따라서 데이터를 읽는 시점에 Lock을 걸고 트랜잭션이 완료될 때까지 유지함

#### 낙관적 동시성 제어(Optimistic Concurrency Control,OCC)

사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정함

따라서 데이터를 읽을 때는 Lock을 설정하지 않음

대신, 수정 시점에 다른 사용자에 의해 값이 변경됐는지 반드시 검사

> DBMS 마다 비관적/낙관적 동시성 제어하는 힌트구문같은게 있음
>
> 필요할 떄 검색하면 된다고 생각함
>
> 개념을 아는게 더 중요

### 다중버전 동시성 제어(MVCC)

읽기 작업에 공유Lock을 거는 일반적인 메커니즘에서는 읽기와 쓰기가 서로 방해를 일으켜 동시성과 일관성 문제가 생기곤 한다

이러한 문제의 대안으로 다중버전 동시성 제어가 나옴

#### MVCC 매커니즘

* 데이터를 변경할 때마다 그 변경사항을 Undo 영역에 저장
* 데이터를 읽다가 트랜잭션 시작 시점 이후에 변경된 값을 발견하면, Undo 영역에 저장된 정보를 이용해 트랜잭션 시작 시점의 일관성 있는 버전을 생성하고 그것을 읽는다

이렇게 하면 쿼리 도중 배타적Lock이 걸린, 즉 변경이 진행중인 레코드를 만나더라도 대기하지 않기 때문에 동시성 측면에서 유리하다

또한 사용자에게 제공되는 데이터의 기준 시점이 트랜잭션 시작 시점으로 고정되므로 일관성에도 유리하다

단,Undo 영역에 저장하기 때문에 Undo 블록 I/O, CR copy 생성, CR블록 캐싱 같은 부가적인 오버헤드가 생김

#### ❓Snapshot too old 에러

Undo 영역에 저장된 Undo 정보가 다른 트랜잭션에 의해 재사용돼 CR copy를 생성할 수 없을 때 발생한다

> 무슨 말인지 잘 모르겠다







