# 챕터1. 알고리즘 기초

## 이진 탐색 알고리즘

이진탐색은 리스트의 원소들이 정렬되어 있을 때만 사용할 수 있음

이진탐색은 O(log n) 시간

## 빅오 표기법

알고리즘이 얼마나 빠른지 표시하는 방법

리스트의 크기가 증가할 때 연산 횟수가 어떻게 증가하는지를 표시함

## 연습문제 1-6

알파벳 A로 시작하는 사람들의 전화번호를 알아내는 방법의 실행 시간

O(n)

알파벳이 26개인데 A로 시작하는 사람들만 뽑아내면 대략 1/26 * n 만큼의 연산이 수행됨

하지만 빅오표기법에서 상수는 무시함

이유1. 리스트의 크기가 매우 커지면 상수는 큰 의미가 없음

이유2. 상수값보다는 리스트의 크기에 따른 연산수행의 변동성(기울기)가 빅오표기법의 관심사임

# 챕터2. 선택 정렬

## 배열과 연결리스트

배열은 메모리상에 일렬로 늘어선 공간에 각 원소가 순차적으로 저장됨

연결리스트의 각 원소는 메모리상에 남는 공간에 흩어져서 저장됨

이 때 원소값과 다음 원소의 주소를 저장함

이러한 구조적 특징 때문에 배열은 검색시간은 O(1) 이지만 삽입/삭제 시간은 O(n)

반대로 연결리스트는 삽입/삭제는 O(1)이지만 검색은 맨 앞의 원소부터 순차적으로 진행해야 되기 떄문에 O(n)의 시간 복잡도를 가짐

## 선택 정렬 알고리즘

시간복잡도는 O(n^2)이다. 깔끔하지만 느린 정렬 알고리즘

## 연습문제 2-4

이진 탐색을 쓰고 있는 배열에 새로운 원소를 추가하면 어떻게 되는가?

일단 배열에 원소를 추가하면 추가한 원소는 가장 마지막 칸에 저장된다. 그러나 이진탐색을 사용하고 있기 때문에 배열의 모든 원소가 정렬되어 있어야 하므로 배열을 다시 정렬해야함

즉, 원소 추가할 때마다 배열을 다시 정렬해야함

## 연습문제 2-5

[연결리스트의 배열] 형태의 복합 자료형과 [배열]과 [연결리스트] 탐색 및 삽입 시 누가 빠른가?

### 탐색

배열 > 연결리스트의 배열 > 연결리스트

연결리스트의 배열 탐색 시 각 연결리스트의 시작점 주소를 갖고 있는 각 배열로 접근할 땐 O(1) 의 시간복잡도를 갖는 임의 접근이고 그 후 특정 원소까지는 순차접근함. 다만 온전히 연결리스트로 구성된 경우보다는 훨씬 짧은 탐색시간이 걸릴 것임

### 삽입

연결리스트 = 연결리스트의 배열 > 배열

연결리스트의 배열에서 배열의 특정 원소로 접근할 때 임의 접근이기 때문에 연결리스트와 같은 성능을 갖는다.

# 재귀

## 기본단계와 재귀단계

기본단계 = 가장 단순한 경우로 재귀단계를 끝내고 무한 반복에 빠지지 않게 함

재귀단계 = 자기 자신을 호출하는 단계

## 호출 스택

함수 호출마다 변수를 저장하고 있는데 이 떄 스택을 사용하여 저장하며 이것이 호출 스택임

각각의 호출이 자기만의 변수값 사본을 갖고 있음

# 퀵 정렬

## 분할정복 알고리즘

기본단계와 재귀단계로 이루어짐,즉 재귀임

## 퀵 정렬

평균적으로 O(n log n) 만큼의 성능을 가짐, 단 최악의 경우엔 O(n^2)

따라서 퀵 정렬을 구현하기 위해선 기준 원소를 무작위로 선택해야함, 그래야 O(n log n)이 됨

## 연습문제 4-4

이진탐색도 분할정복이다. 이진탐색을 분할정복으로 설명하면?

기본단계 = 배열의 길이가 1개이다

재귀단계 = 배열을 쪼갤 중간값과 선택값이 같지 않다. 그래서 배열을 2등분한다
